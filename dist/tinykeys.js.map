{"version":3,"file":"tinykeys.js","sources":["../src/tinykeys.ts"],"sourcesContent":["/**\r\n * A single press of a keybinding sequence\r\n */\r\nexport type KeyBindingPress = [mods: string[], key: string | RegExp]\r\n\r\n/**\r\n * A map of keybinding strings to event handlers.\r\n */\r\nexport interface KeyBindingMap {\r\n\t[keybinding: string]: (event: KeyboardEvent) => void\r\n}\r\n\r\nexport interface KeyBindingHandlerOptions {\r\n\t/**\r\n\t * Keybinding sequences will wait this long between key presses before\r\n\t * cancelling (default: 1000).\r\n\t *\r\n\t * **Note:** Setting this value too low (i.e. `300`) will be too fast for many\r\n\t * of your users.\r\n\t */\r\n\ttimeout?: number\r\n}\r\n\r\n/**\r\n * Options to configure the behavior of keybindings.\r\n */\r\nexport interface KeyBindingOptions extends KeyBindingHandlerOptions {\r\n\t/**\r\n\t * Key presses will listen to this event (default: \"keydown\").\r\n\t */\r\n\tevent?: \"keydown\" | \"keyup\"\r\n\r\n\t/**\r\n\t * Key presses will use a capture listener (default: false)\r\n\t */\r\n\tcapture?: boolean\r\n}\r\n\r\n/**\r\n * These are the modifier keys that change the meaning of keybindings.\r\n *\r\n * Note: Ignoring \"AltGraph\" because it is covered by the others.\r\n */\r\nlet KEYBINDING_MODIFIER_KEYS = [\"Shift\", \"Meta\", \"Alt\", \"Control\"]\r\n\r\n/**\r\n * Keybinding sequences should timeout if individual key presses are more than\r\n * 1s apart by default.\r\n */\r\nlet DEFAULT_TIMEOUT = 1000\r\n\r\n/**\r\n * Keybinding sequences should bind to this event by default.\r\n */\r\nlet DEFAULT_EVENT = \"keydown\" as const\r\n\r\n/**\r\n * Platform detection code.\r\n * @see https://github.com/jamiebuilds/tinykeys/issues/184\r\n */\r\nlet PLATFORM = typeof navigator === \"object\" ? navigator.platform : \"\"\r\nlet APPLE_DEVICE = /Mac|iPod|iPhone|iPad/.test(PLATFORM)\r\n\r\n/**\r\n * An alias for creating platform-specific keybinding aliases.\r\n */\r\nlet MOD = APPLE_DEVICE ? \"Meta\" : \"Control\"\r\n\r\n/**\r\n * Meaning of `AltGraph`, from MDN:\r\n * - Windows: Both Alt and Ctrl keys are pressed, or AltGr key is pressed\r\n * - Mac: ‚å• Option key pressed\r\n * - Linux: Level 3 Shift key (or Level 5 Shift key) pressed\r\n * - Android: Not supported\r\n * @see https://github.com/jamiebuilds/tinykeys/issues/185\r\n */\r\nlet ALT_GRAPH_ALIASES =\r\n\tPLATFORM === \"Win32\" ? [\"Control\", \"Alt\"] : APPLE_DEVICE ? [\"Alt\"] : []\r\n\r\n/**\r\n * There's a bug in Chrome that causes event.getModifierState not to exist on\r\n * KeyboardEvent's for F1/F2/etc keys.\r\n */\r\nfunction getModifierState(event: KeyboardEvent, mod: string) {\r\n\treturn typeof event.getModifierState === \"function\"\r\n\t\t? event.getModifierState(mod) ||\r\n\t\t\t\t(ALT_GRAPH_ALIASES.includes(mod) && event.getModifierState(\"AltGraph\"))\r\n\t\t: false\r\n}\r\n\r\n/**\r\n * Parses a \"Key Binding String\" into its parts\r\n *\r\n * grammar    = `<sequence>`\r\n * <sequence> = `<press> <press> <press> ...`\r\n * <press>    = `<key>` or `<mods>+<key>`\r\n * <mods>     = `<mod>+<mod>+...`\r\n * <key>      = `<KeyboardEvent.key>` or `<KeyboardEvent.code>` (case-insensitive)\r\n * <key>      = `(<regex>)` -> `/^<regex>$/` (case-sensitive)\r\n */\r\nexport function parseKeybinding(str: string): KeyBindingPress[] {\r\n\treturn str\r\n\t\t.trim()\r\n\t\t.split(\" \")\r\n\t\t.map(press => {\r\n\t\t\tlet mods = press.split(/\\b\\+/)\r\n\t\t\tlet key: string | RegExp = mods.pop() as string\r\n\t\t\tlet match = key.match(/^\\((.+)\\)$/)\r\n\t\t\tif (match) {\r\n\t\t\t\tkey = new RegExp(`^${match[1]}$`)\r\n\t\t\t}\r\n\t\t\tmods = mods.map(mod => (mod === \"$mod\" ? MOD : mod))\r\n\t\t\treturn [mods, key]\r\n\t\t})\r\n}\r\n\r\n/**\r\n * This tells us if a single keyboard event matches a single keybinding press.\r\n */\r\nexport function matchKeyBindingPress(\r\n\tevent: KeyboardEvent,\r\n\t[mods, key]: KeyBindingPress,\r\n): boolean {\r\n\t// prettier-ignore\r\n\treturn !(\r\n\t\t// Allow either the `event.key` or the `event.code`\r\n\t\t// MDN event.key: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\r\n\t\t// MDN event.code: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\r\n\t\t(\r\n\t\t\tkey instanceof RegExp ? !(key.test(event.key) || key.test(event.code)) :\r\n\t\t\t(key.toUpperCase() !== event.key.toUpperCase() &&\r\n\t\t\tkey !== event.code)\r\n\t\t) ||\r\n\r\n\t\t// Ensure all the modifiers in the keybinding are pressed.\r\n\t\tmods.find(mod => {\r\n\t\t\treturn !getModifierState(event, mod)\r\n\t\t}) ||\r\n\r\n\t\t// KEYBINDING_MODIFIER_KEYS (Shift/Control/etc) change the meaning of a\r\n\t\t// keybinding. So if they are pressed but aren't part of the current\r\n\t\t// keybinding press, then we don't have a match.\r\n\t\tKEYBINDING_MODIFIER_KEYS.find(mod => {\r\n\t\t\treturn !mods.includes(mod) && key !== mod && getModifierState(event, mod)\r\n\t\t})\r\n\t)\r\n}\r\n\r\n/**\r\n * Creates an event listener for handling keybindings.\r\n *\r\n * @example\r\n * ```js\r\n * import { createKeybindingsHandler } from \"../src/keybindings\"\r\n *\r\n * let handler = createKeybindingsHandler({\r\n * \t\"Shift+d\": () => {\r\n * \t\talert(\"The 'Shift' and 'd' keys were pressed at the same time\")\r\n * \t},\r\n * \t\"y e e t\": () => {\r\n * \t\talert(\"The keys 'y', 'e', 'e', and 't' were pressed in order\")\r\n * \t},\r\n * \t\"$mod+d\": () => {\r\n * \t\talert(\"Either 'Control+d' or 'Meta+d' were pressed\")\r\n * \t},\r\n * })\r\n *\r\n * window.addEvenListener(\"keydown\", handler)\r\n * ```\r\n */\r\nexport function createKeybindingsHandler(\r\n\tkeyBindingMap: KeyBindingMap,\r\n\toptions: KeyBindingHandlerOptions = {},\r\n): EventListener {\r\n\tlet timeout = options.timeout ?? DEFAULT_TIMEOUT\r\n\r\n\tlet keyBindings = Object.keys(keyBindingMap).map(key => {\r\n\t\treturn [parseKeybinding(key), keyBindingMap[key]] as const\r\n\t})\r\n\r\n\tlet possibleMatches = new Map<KeyBindingPress[], KeyBindingPress[]>()\r\n\tlet timer: number | null = null\r\n\r\n\treturn event => {\r\n\t\t// Ensure and stop any event that isn't a full keyboard event.\r\n\t\t// Autocomplete option navigation and selection would fire a instanceof Event,\r\n\t\t// instead of the expected KeyboardEvent\r\n\t\tif (!(event instanceof KeyboardEvent)) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tkeyBindings.forEach(keyBinding => {\r\n\t\t\tlet sequence = keyBinding[0]\r\n\t\t\tlet callback = keyBinding[1]\r\n\r\n\t\t\tlet prev = possibleMatches.get(sequence)\r\n\t\t\tlet remainingExpectedPresses = prev ? prev : sequence\r\n\t\t\tlet currentExpectedPress = remainingExpectedPresses[0]\r\n\r\n\t\t\tlet matches = matchKeyBindingPress(event, currentExpectedPress)\r\n\r\n\t\t\tif (!matches) {\r\n\t\t\t\t// Modifier keydown events shouldn't break sequences\r\n\t\t\t\t// Note: This works because:\r\n\t\t\t\t// - non-modifiers will always return false\r\n\t\t\t\t// - if the current keypress is a modifier then it will return true when we check its state\r\n\t\t\t\t// MDN: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState\r\n\t\t\t\tif (!getModifierState(event, event.key)) {\r\n\t\t\t\t\tpossibleMatches.delete(sequence)\r\n\t\t\t\t}\r\n\t\t\t} else if (remainingExpectedPresses.length > 1) {\r\n\t\t\t\tpossibleMatches.set(sequence, remainingExpectedPresses.slice(1))\r\n\t\t\t} else {\r\n\t\t\t\tpossibleMatches.delete(sequence)\r\n\t\t\t\tcallback(event)\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tif (timer) {\r\n\t\t\tclearTimeout(timer)\r\n\t\t}\r\n\r\n\t\ttimer = setTimeout(possibleMatches.clear.bind(possibleMatches), timeout)\r\n\t}\r\n}\r\n\r\n/**\r\n * Subscribes to keybindings.\r\n *\r\n * Returns an unsubscribe method.\r\n *\r\n * @example\r\n * ```js\r\n * import { tinykeys } from \"../src/tinykeys\"\r\n *\r\n * tinykeys(window, {\r\n * \t\"Shift+d\": () => {\r\n * \t\talert(\"The 'Shift' and 'd' keys were pressed at the same time\")\r\n * \t},\r\n * \t\"y e e t\": () => {\r\n * \t\talert(\"The keys 'y', 'e', 'e', and 't' were pressed in order\")\r\n * \t},\r\n * \t\"$mod+d\": () => {\r\n * \t\talert(\"Either 'Control+d' or 'Meta+d' were pressed\")\r\n * \t},\r\n * })\r\n * ```\r\n */\r\nexport function tinykeys(\r\n\ttarget: Window | HTMLElement,\r\n\tkeyBindingMap: KeyBindingMap,\r\n\t{ event = DEFAULT_EVENT, capture, timeout }: KeyBindingOptions = {},\r\n): () => void {\r\n\tlet onKeyEvent = createKeybindingsHandler(keyBindingMap, { timeout })\r\n\ttarget.addEventListener(event, onKeyEvent, capture)\r\n\treturn () => {\r\n\t\ttarget.removeEventListener(event, onKeyEvent, capture)\r\n\t}\r\n}\r\n"],"names":["KEYBINDING_MODIFIER_KEYS","PLATFORM","navigator","platform","APPLE_DEVICE","test","MOD","ALT_GRAPH_ALIASES","getModifierState","event","mod","includes","parseKeybinding","str","trim","split","map","press","mods","key","pop","match","RegExp","matchKeyBindingPress","_ref","code","toUpperCase","find","createKeybindingsHandler","keyBindingMap","options","timeout","_options$timeout","keyBindings","Object","keys","possibleMatches","Map","timer","KeyboardEvent","forEach","keyBinding","sequence","callback","remainingExpectedPresses","get","length","set","slice","clearTimeout","setTimeout","clear","bind","target","_temp","_ref2$event","_ref2","capture","onKeyEvent","addEventListener","removeEventListener"],"mappings":"AA2CA,IAAIA,EAA2B,CAAC,QAAS,OAAQ,MAAO,WAiBpDC,EAAgC,iBAAdC,UAAyBA,UAAUC,SAAW,GAChEC,EAAe,uBAAuBC,KAAKJ,GAK3CK,EAAMF,EAAe,OAAS,UAU9BG,EACU,UAAbN,EAAuB,CAAC,UAAW,OAASG,EAAe,CAAC,OAAS,GAMtE,SAASI,EAAiBC,EAAsBC,GAC/C,MAAyC,mBAA3BD,EAAMD,mBACjBC,EAAMD,iBAAiBE,IACtBH,EAAkBI,SAASD,IAAQD,EAAMD,iBAAiB,sBAc/CI,EAAgBC,GAC/B,OAAOA,EACLC,OACAC,MAAM,KACNC,IAAI,SAAAC,GACJ,IAAIC,EAAOD,EAAMF,MAAM,QACnBI,EAAuBD,EAAKE,MAC5BC,EAAQF,EAAIE,MAAM,cAKtB,OAJIA,IACHF,EAAM,IAAIG,WAAWD,EAAM,SAGrB,CADPH,EAAOA,EAAKF,IAAI,SAAAN,SAAgB,SAARA,EAAiBJ,EAAMI,IACjCS,cAODI,EACfd,EAAoBe,OACnBN,EAAIM,KAAEL,EAAGK,KAGV,SAKEL,aAAeG,QAAWH,EAAId,KAAKI,EAAMU,OAAQA,EAAId,KAAKI,EAAMgB,MAC/DN,EAAIO,gBAAkBjB,EAAMU,IAAIO,eACjCP,IAAQV,EAAMgB,OAIfP,EAAKS,KAAK,SAAAjB,GACT,OAAQF,EAAiBC,EAAOC,MAMjCV,EAAyB2B,KAAK,SAAAjB,GAC7B,OAAQQ,EAAKP,SAASD,IAAQS,IAAQT,GAAOF,EAAiBC,EAAOC,eA2BxDkB,EACfC,EACAC,kBAAAA,IAAAA,EAAoC,IAEpC,IAAIC,SAAOC,EAAGF,EAAQC,SAAOC,EA7HR,IA+HjBC,EAAcC,OAAOC,KAAKN,GAAeb,IAAI,SAAAG,GAChD,MAAO,CAACP,EAAgBO,GAAMU,EAAcV,MAGzCiB,EAAkB,IAAIC,IACtBC,EAAuB,KAE3B,gBAAO7B,GAIAA,aAAiB8B,gBAIvBN,EAAYO,QAAQ,SAAAC,GACnB,IAAIC,EAAWD,EAAW,GACtBE,EAAWF,EAAW,GAGtBG,EADOR,EAAgBS,IAAIH,IACcA,EAG/BnB,EAAqBd,EAFRmC,EAAyB,IAazCA,EAAyBE,OAAS,EAC5CV,EAAgBW,IAAIL,EAAUE,EAAyBI,MAAM,KAE7DZ,SAAuBM,GACvBC,EAASlC,IAPJD,EAAiBC,EAAOA,EAAMU,MAClCiB,SAAuBM,KAUtBJ,GACHW,aAAaX,GAGdA,EAAQY,WAAWd,EAAgBe,MAAMC,KAAKhB,GAAkBL,2HA2BjEsB,EACAxB,EAA4ByB,oBACqC,GAAEA,EAAAC,EAAAC,EAAjE/C,MAAAA,WAAK8C,EArMY,UAqMIA,EAAEE,EAAOD,EAAPC,QAErBC,EAAa9B,EAAyBC,EAAe,CAAEE,QAFlByB,EAAPzB,UAIlC,OADAsB,EAAOM,iBAAiBlD,EAAOiD,EAAYD,cAE1CJ,EAAOO,oBAAoBnD,EAAOiD,EAAYD"}